# slot 
	v4
                       {
								"astId": 4,
								"contract": "contracts/V4.sol:v4",
								"label": "_nextId",
								"offset": 0,
								"slot": "0",
								"type": "t_uint256"
							},
							{
								"astId": 6,
								"contract": "contracts/V4.sol:v4",
								"label": "tokenImplementation",
								"offset": 0,
								"slot": "1",
								"type": "t_address"
							},
							{
								"astId": 8,
								"contract": "contracts/V4.sol:v4",
								"label": "daoImplementation",
								"offset": 0,
								"slot": "2",
								"type": "t_address"
							},
							{
								"astId": 10,
								"contract": "contracts/V4.sol:v4",
								"label": "nft",
								"offset": 0,
								"slot": "3",
								"type": "t_address"
							},
							{
								"astId": 12,
								"contract": "contracts/V4.sol:v4",
								"label": "tbaRegistry",
								"offset": 0,
								"slot": "4",
								"type": "t_address"
							},
							{
								"astId": 14,
								"contract": "contracts/V4.sol:v4",
								"label": "applicationThreshold",
								"offset": 0,
								"slot": "5",
								"type": "t_uint256"
							},
							{
								"astId": 17,
								"contract": "contracts/V4.sol:v4",
								"label": "allTokens",
								"offset": 0,
								"slot": "6",
								"type": "t_array(t_address)dyn_storage"
							},
							{
								"astId": 20,
								"contract": "contracts/V4.sol:v4",
								"label": "allDAOs",
								"offset": 0,
								"slot": "7",
								"type": "t_array(t_address)dyn_storage"
							},
							{
								"astId": 22,
								"contract": "contracts/V4.sol:v4",
								"label": "assetToken",
								"offset": 0,
								"slot": "8",
								"type": "t_address"
							},
							{
								"astId": 24,
								"contract": "contracts/V4.sol:v4",
								"label": "maturityDuration",
								"offset": 0,
								"slot": "9",
								"type": "t_uint256"
							},
							{
								"astId": 85,
								"contract": "contracts/V4.sol:v4",
								"label": "_applications",
								"offset": 0,
								"slot": "10",
								"type": "t_mapping(t_uint256,t_struct(Application)80_storage)"
							},
							{
								"astId": 101,
								"contract": "contracts/V4.sol:v4",
								"label": "_vault",
								"offset": 0,
								"slot": "11",
								"type": "t_address"
							},
							{
								"astId": 103,
								"contract": "contracts/V4.sol:v4",
								"label": "locked",
								"offset": 20,
								"slot": "11",
								"type": "t_bool"
							},
							{
								"astId": 124,
								"contract": "contracts/V4.sol:v4",
								"label": "allTradingTokens",
								"offset": 0,
								"slot": "12",
								"type": "t_array(t_address)dyn_storage"
							},
							{
								"astId": 126,
								"contract": "contracts/V4.sol:v4",
								"label": "_uniswapRouter",
								"offset": 0,
								"slot": "13",
								"type": "t_address"
							},
							{
								"astId": 128,
								"contract": "contracts/V4.sol:v4",
								"label": "veTokenImplementation",
								"offset": 0,
								"slot": "14",
								"type": "t_address"
							},
							{
								"astId": 130,
								"contract": "contracts/V4.sol:v4",
								"label": "_tokenAdmin",
								"offset": 0,
								"slot": "15",
								"type": "t_address"
							},
							{
								"astId": 132,
								"contract": "contracts/V4.sol:v4",
								"label": "defaultDelegatee",
								"offset": 0,
								"slot": "16",
								"type": "t_address"
							},
							{
								"astId": 134,
								"contract": "contracts/V4.sol:v4",
								"label": "_tokenSupplyParams",
								"offset": 0,
								"slot": "17",
								"type": "t_bytes_storage"
							},
							{
								"astId": 136,
								"contract": "contracts/V4.sol:v4",
								"label": "_tokenTaxParams",
								"offset": 0,
								"slot": "18",
								"type": "t_bytes_storage"
							},
							{
								"astId": 140,
								"contract": "contracts/V4.sol:v4",
								"label": "_tokenApplication",
								"offset": 0,
								"slot": "19",
								"type": "t_mapping(t_address,t_uint256)"
							},
							{
								"astId": 144,
								"contract": "contracts/V4.sol:v4",
								"label": "_applicationToken",
								"offset": 0,
								"slot": "20",
								"type": "t_mapping(t_uint256,t_address)"
							}





          -v3

							{
								"astId": 4,
								"contract": "contracts/V3.sol:v3",
								"label": "_nextId",
								"offset": 0,
								"slot": "0",
								"type": "t_uint256"
							},
							{
								"astId": 6,
								"contract": "contracts/V3.sol:v3",
								"label": "tokenImplementation",
								"offset": 0,
								"slot": "1",
								"type": "t_address"
							},
							{
								"astId": 8,
								"contract": "contracts/V3.sol:v3",
								"label": "daoImplementation",
								"offset": 0,
								"slot": "2",
								"type": "t_address"
							},
							{
								"astId": 10,
								"contract": "contracts/V3.sol:v3",
								"label": "nft",
								"offset": 0,
								"slot": "3",
								"type": "t_address"
							},
							{
								"astId": 12,
								"contract": "contracts/V3.sol:v3",
								"label": "tbaRegistry",
								"offset": 0,
								"slot": "4",
								"type": "t_address"
							},
							{
								"astId": 14,
								"contract": "contracts/V3.sol:v3",
								"label": "applicationThreshold",
								"offset": 0,
								"slot": "5",
								"type": "t_uint256"
							},
							{
								"astId": 17,
								"contract": "contracts/V3.sol:v3",
								"label": "allTokens",
								"offset": 0,
								"slot": "6",
								"type": "t_array(t_address)dyn_storage"
							},
							{
								"astId": 20,
								"contract": "contracts/V3.sol:v3",
								"label": "allDAOs",
								"offset": 0,
								"slot": "7",
								"type": "t_array(t_address)dyn_storage"
							},
							{
								"astId": 22,
								"contract": "contracts/V3.sol:v3",
								"label": "assetToken",
								"offset": 0,
								"slot": "8",
								"type": "t_address"
							},
							{
								"astId": 24,
								"contract": "contracts/V3.sol:v3",
								"label": "maturityDuration",
								"offset": 0,
								"slot": "9",
								"type": "t_uint256"
							},
							{
								"astId": 85,
								"contract": "contracts/V3.sol:v3",
								"label": "_applications",
								"offset": 0,
								"slot": "10",
								"type": "t_mapping(t_uint256,t_struct(Application)80_storage)"
							},
							{
								"astId": 87,
								"contract": "contracts/V3.sol:v3",
								"label": "gov",
								"offset": 0,
								"slot": "11",
								"type": "t_address"
							},
							{
								"astId": 115,
								"contract": "contracts/V3.sol:v3",
								"label": "_vault",
								"offset": 0,
								"slot": "12",
								"type": "t_address"
							},
							{
								"astId": 117,
								"contract": "contracts/V3.sol:v3",
								"label": "locked",
								"offset": 20,
								"slot": "12",
								"type": "t_bool"
							},
							{
								"astId": 138,
								"contract": "contracts/V3.sol:v3",
								"label": "allTradingTokens",
								"offset": 0,
								"slot": "13",
								"type": "t_array(t_address)dyn_storage"
							},
							{
								"astId": 140,
								"contract": "contracts/V3.sol:v3",
								"label": "_uniswapRouter",
								"offset": 0,
								"slot": "14",
								"type": "t_address"
							},
							{
								"astId": 142,
								"contract": "contracts/V3.sol:v3",
								"label": "veTokenImplementation",
								"offset": 0,
								"slot": "15",
								"type": "t_address"
							},
							{
								"astId": 144,
								"contract": "contracts/V3.sol:v3",
								"label": "_minter",
								"offset": 0,
								"slot": "16",
								"type": "t_address"
							},
							{
								"astId": 146,
								"contract": "contracts/V3.sol:v3",
								"label": "_tokenAdmin",
								"offset": 0,
								"slot": "17",
								"type": "t_address"
							},
							{
								"astId": 148,
								"contract": "contracts/V3.sol:v3",
								"label": "defaultDelegatee",
								"offset": 0,
								"slot": "18",
								"type": "t_address"
							},
							{
								"astId": 150,
								"contract": "contracts/V3.sol:v3",
								"label": "_tokenSupplyParams",
								"offset": 0,
								"slot": "19",
								"type": "t_bytes_storage"
							},
							{
								"astId": 152,
								"contract": "contracts/V3.sol:v3",
								"label": "_tokenTaxParams",
								"offset": 0,
								"slot": "20",
								"type": "t_bytes_storage"
							},
							{
								"astId": 154,
								"contract": "contracts/V3.sol:v3",
								"label": "_tokenMultiplier",
								"offset": 0,
								"slot": "21",
								"type": "t_uint16"
							}                  

# report

可升级合约 V3 到 V4 的 Slot 分布对比与冲突分析

以下对 V3 和 V4 合约的存储布局进行逐 Slot 对比，标注可能引发 存储冲突（Storage Collision） 的变更点（基于搜索结果中提到的存储布局规则）：

---

**Slot 0-10**  
• V3 与 V4 完全一致，包括变量类型、顺序和名称。  

  • 例如：Slot 0 的 `_nextId`（`uint256`）、Slot 10 的 `_applications`（映射）等。  

  • 无冲突风险 ✅


---

**Slot 11**  
• V3：`gov`（地址，占满整个 Slot）  

• V4：`_vault`（地址，占前 20 字节） + `locked`（布尔，占第 21 字节）  

• 冲突类型：变量覆盖  

  • V4 的 `_vault` 会覆盖 V3 的 `gov` 地址，导致 `gov` 功能失效。  

  • `locked` 占用 V3 中未使用的 Slot 剩余空间，但需注意初始化逻辑是否兼容。  


---

**Slot 12**  
• V3：`_vault`（地址） + `locked`（布尔）  

• V4：`allTradingTokens`（动态地址数组）  

• 冲突类型：存储结构破坏  

  • 动态数组的 Slot 12 存储数组长度，而 V3 中此处为地址和布尔值，升级后数组长度会覆盖原有数据。  


---

**Slot 13**  
• V3：`allTradingTokens`（动态地址数组）  

• V4：`_uniswapRouter`（地址）  

• 冲突类型：类型不匹配  

  • V3 的 Slot 13 存储动态数组长度，V4 直接写入地址值，导致长度字段被破坏。  


---

**Slot 14-16**  
• V3 → V4：  

  • Slot 14：`_uniswapRouter` → `veTokenImplementation`（均为地址）  

  • Slot 15：`veTokenImplementation` → `_tokenAdmin`（均为地址）  

  • Slot 16：`_minter` → `defaultDelegatee`（均为地址）  

• 冲突类型：逻辑语义冲突  

  • 变量名称和用途改变，但存储类型一致。需确保升级后逻辑合约能正确处理重命名的变量。  


---

**Slot 17**  
• V3：`_tokenAdmin`（地址）  

• V4：`_tokenSupplyParams`（动态字节数组）  

• 冲突类型：存储结构破坏  

  • 动态字节数组的 Slot 17 存储长度，而 V3 此处为地址值，升级后长度字段会覆盖地址数据。  


---

**Slot 19-20**  
• V3 → V4：  

  • Slot 19：`_tokenSupplyParams`（动态字节数组） → `_tokenApplication`（映射）  

  • Slot 20：`_tokenTaxParams`（动态字节数组） → `_applicationToken`（映射）  

• 冲突类型：类型不匹配  

  • 动态字节数组与映射的存储方式完全不同（动态类型需哈希计算存储位置），直接替换会导致数据混乱。  


---

**Slot 21**  
• V3：`_tokenMultiplier`（`uint16`）  

• V4：未使用  

• 冲突类型：潜在数据残留  

  • 若 V4 新增变量从 Slot 21 开始，需确保旧数据残留不会影响新逻辑（通常需初始化清理）。  


---

总结与建议  
1. 高风险冲突点：  
   • Slot 11、12、13、17、19、20 的存储结构或类型变更会导致数据覆盖或逻辑错误，必须修复。  

2. 升级规则遵循：  
   • 仅允许在存储布局末尾追加变量，禁止删除、重排或类型变更。  

3. 验证工具：  
   • 使用 `forge inspect` 或类似工具对比存储布局，确保兼容性。  


如需进一步排查具体逻辑兼容性，建议结合代理模式（如 OpenZeppelin 升级库）进行测试。

## Bonding pool is vulernable to sandwich attack


## Finding description and impact
In `contract/fun/bonding.sol`, `buy()` and `sell()` function does not have any slippage protection to prevent potential sandwich attack.

```solidity
    function sell(uint256 amountIn, address tokenAddress) public returns (bool) {
        require(tokenInfo[tokenAddress].trading, "Token not trading");

        address pairAddress = factory.getPair(tokenAddress, router.assetToken());

        IFPair pair = IFPair(pairAddress);

        (uint256 reserveA, uint256 reserveB) = pair.getReserves();

        (uint256 amount0In, uint256 amount1Out) = router.sell(amountIn, tokenAddress, msg.sender);

      ....
    }

    function buy(uint256 amountIn, address tokenAddress) public payable returns (bool) {
        require(tokenInfo[tokenAddress].trading, "Token not trading");

        address pairAddress = factory.getPair(tokenAddress, router.assetToken());

        IFPair pair = IFPair(pairAddress);

        (uint256 reserveA, uint256 reserveB) = pair.getReserves();

        (uint256 amount1In, uint256 amount0Out) = router.buy(amountIn, tokenAddress, msg.sender);

         ....
    }
```
And the calculation of amountOut simply relies on `FRouter::getAmountsOut()`, which calcuates the amoutOut based on `x*y=k`.

```solidity
   function getAmountsOut(
        address token,
        address assetToken_,
        uint256 amountIn
    ) public view returns (uint256 _amountOut) {
        require(token != address(0), "Zero addresses are not allowed.");

        address pairAddress = factory.getPair(token, assetToken);

        IFPair pair = IFPair(pairAddress);

        (uint256 reserveA, uint256 reserveB) = pair.getReserves();

        uint256 k = pair.kLast();

        uint256 amountOut;

        if (assetToken_ == assetToken) {//calculate the funToken out in buying 
            uint256 newReserveB = reserveB + amountIn;

            uint256 newReserveA = k / newReserveB;

            amountOut = reserveA - newReserveA;
        } else {//calculate the the assetToken out in selling
            uint256 newReserveA = reserveA + amountIn;

            uint256 newReserveB = k / newReserveA;

            amountOut = reserveB - newReserveB;
        }

        return amountOut;
    }
```


An attacker can directly gain profit by front-running the 



## Recommended mitigation steps





## Finding description and impact

When a fun token is bought enough amount to graduate, `bonding::_openTradingOnUniswap()` would execute the graduate process,which incluedes following actions

```solidity
 function _openTradingOnUniswap(address tokenAddress) private {
        FERC20 token_ = FERC20(tokenAddress);

        Token storage _token = tokenInfo[tokenAddress];

        require(_token.trading && !_token.tradingOnUniswap, "trading is already open");
        //1.change the _token state
        _token.trading = false;
        _token.tradingOnUniswap = true;

        //2.Transfer all asset tokens from pair to bonding contract
        address pairAddress = factory.getPair(tokenAddress, router.assetToken());

        IFPair pair = IFPair(pairAddress);

        uint256 assetBalance = pair.assetBalance();
        uint256 tokenBalance = pair.balance();

        router.graduate(tokenAddress);//transfer assetToken from pair to bonding contract
        

       //3. Transfer all assetToken from bonding to agentFactory to initialize an application 
        IERC20(router.assetToken()).forceApprove(agentFactory, assetBalance);
        uint256 id = IAgentFactoryV3(agentFactory).initFromBondingCurve(
            string.concat(_token.data._name, " by Virtuals"),
            _token.data.ticker,
            _token.cores,
            _deployParams.tbaSalt,
            _deployParams.tbaImplementation,
            _deployParams.daoVotingPeriod,
            _deployParams.daoThreshold,
            assetBalance,
            _token.creator
        );

        address agentToken = IAgentFactoryV3(agentFactory).executeBondingCurveApplication(
            id,
            _token.data.supply / (10 ** token_.decimals()),
            tokenBalance / (10 ** token_.decimals()),
            pairAddress
        );
        

       //4. other left actions
        _token.agentToken = agentToken;

        router.approval(pairAddress, agentToken, address(this), IERC20(agentToken).balanceOf(pairAddress));

        token_.burnFrom(pairAddress, tokenBalance);

        emit Graduated(tokenAddress, agentToken);
    }
```

In step3, ` //3. Transfer all assetToken from bonding to agentFactory to initialize an application `, all assetToken will be transfered to `agentFactory` and added into a newly created uniswap pool with newly created agentToken.

The lp token returned by uniswap would be then staked into `AgentVeToken`, and `AgentVeToken` will mint the same amount of `veToken` to `application.proposer` which in the case of graduation is the fun token founder.

```solidity
  // C7
        IERC20(lp).approve(veToken, type(uint256).max);
        IAgentVeToken(veToken).stake(IERC20(lp).balanceOf(address(this)), application.proposer, defaultDelegatee);
```

`veToken` is the voting token in `agentDAO`, and fun token founder will be distributed all `veToken` once the fun token is graduated.

However, this can be unfair for other participants who contributed to the community, because they spent their assetToken to buy fun token until it is graduated, but eventually end up with zero voting power in the new DAO.

Moreover,  `veToken` is not transferable and the only way to gain `veToken` is to add more tokens agent and assetToken in 


## Recommended mitigation steps

Describe the best method(s) to mitigate the finding.

add `minOut` input for users to prevent potential sandwich attack










```solidity
    function nft_addCoreType(string memory label) public updateGhosts asActor {
        nft.addCoreType(label);
    }

    function nft_addValidator(uint256 virtualId, address validator) public updateGhosts asActor {
        nft.addValidator(virtualId, validator);
    }

    function nft_approve(address to, uint256 tokenId) public updateGhosts asActor {
        nft.approve(to, tokenId);
    }

    function nft_grantRole(bytes32 role, address account) public updateGhosts asActor {
        nft.grantRole(role, account);
    }

    function nft_initialize(address defaultAdmin) public updateGhosts asActor {
        nft.initialize(defaultAdmin);
    }

    function nft_migrateScoreFunctions() public updateGhosts asActor {
        nft.migrateScoreFunctions();
    }

    function nft_migrateVirtual(uint256 virtualId, address dao, address token, address pool, address veToken) public updateGhosts asActor {
        nft.migrateVirtual(virtualId, dao, token, pool, veToken);
    }

    function nft_mint(uint256 virtualId, address to, string memory newTokenURI, address theDAO, address founder, uint8[] memory coreTypes, address pool, address token) public updateGhosts asActor {
        nft.mint(virtualId, to, newTokenURI, theDAO, founder, coreTypes, pool, token);
    }

    function nft_renounceRole(bytes32 role, address callerConfirmation) public updateGhosts asActor {
        nft.renounceRole(role, callerConfirmation);
    }

    function nft_revokeRole(bytes32 role, address account) public updateGhosts asActor {
        nft.revokeRole(role, account);
    }

    function nft_safeTransferFrom(address from, address to, uint256 tokenId) public updateGhosts asActor {
        nft.safeTransferFrom(from, to, tokenId);
    }

    function nft_safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public updateGhosts asActor {
        nft.safeTransferFrom(from, to, tokenId, data);
    }

    function nft_setApprovalForAll(address operator, bool approved) public updateGhosts asActor {
        nft.setApprovalForAll(operator, approved);
    }

    function nft_setBlacklist(uint256 virtualId, bool value) public updateGhosts asActor {
        nft.setBlacklist(virtualId, value);
    }

    function nft_setContributionService(address contributionNft_, address serviceNft_) public updateGhosts asActor {
        nft.setContributionService(contributionNft_, serviceNft_);
    }

    function nft_setCoreTypes(uint256 virtualId, uint8[] memory coreTypes) public updateGhosts asActor {
        nft.setCoreTypes(virtualId, coreTypes);
    }

    function nft_setDAO(uint256 virtualId, address newDAO) public updateGhosts asActor {
        nft.setDAO(virtualId, newDAO);
    }

    function nft_setEloCalculator(address eloCalculator) public updateGhosts asActor {
        nft.setEloCalculator(eloCalculator);
    }

    function nft_setTBA(uint256 virtualId, address tba) public updateGhosts asActor {
        nft.setTBA(virtualId, tba);
    }

    function nft_setTokenURI(uint256 virtualId, string memory newTokenURI) public updateGhosts asActor {
        nft.setTokenURI(virtualId, newTokenURI);
    }

    function nft_transferFrom(address from, address to, uint256 tokenId) public updateGhosts asActor {
        nft.transferFrom(from, to, tokenId);
    }

    /// === Managers Targets === ///
    // == ACTOR HANDLERS == //
    
    /// @dev Start acting as another actor
    function switchActor(uint256 entropy) public {
        _switchActor(entropy);
    }


    /// @dev Starts using a new asset
    function switch_asset(uint256 entropy) public {
        _switchAsset(entropy);
    }

    /// @dev Deploy a new token and add it to the list of assets, then set it as the current asset
    function add_new_asset(uint8 decimals) public returns (address) {
        address newAsset = _newAsset(decimals);
        return newAsset;
    }

    /// === GHOST UPDATING HANDLERS ===///
    /// We `updateGhosts` cause you never know (e.g. donations)
    /// If you don't want to track donations, remove the `updateGhosts`

    /// @dev Approve to arbitrary address, uses Actor by default
    /// NOTE: You're almost always better off setting approvals in `Setup`
    function asset_approve(address to, uint128 amt) public updateGhosts asActor {
        MockERC20(_getAsset()).approve(to, amt);
    }

    /// @dev Mint to arbitrary address, uses owner by default, even though MockERC20 doesn't check
    function asset_mint(address to, uint128 amt) public updateGhosts asAdmin {
        MockERC20(_getAsset()).mint(to, amt);
    }
```